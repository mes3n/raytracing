#include "camera.h"
#include "hittables.h"
#include "material.h"
#include "ray.h"
#include "vec3.h"

bool init_camera(Camera *camera, const double aspect_ratio, const int samples) {
    camera->samples_per_pixel = samples;
    camera->max_depth = 50;

    camera->origin = vec3_from(13.0, 2.0, 3.0);
    Vec3 look_at = vec3_from(0.0, 0.0, 0.0);
    Vec3 vup = vec3_from(0.0, 1.0, 0.0);

    double vfov = M_PI / 9.0;
    double focus_dist = 10.0;
    camera->defocus_angle = 0.6 * (M_PI / 180.0);
    double viewport_height = 2.0 * tan(vfov * 0.5) * focus_dist;
    double viewport_width = viewport_height * aspect_ratio;

    Vec3 w = vec3_normal(vec3_sub(camera->origin, look_at));
    Vec3 u = vec3_normal(vec3_cross(vup, w));
    Vec3 v = vec3_cross(w, u);

    camera->viewport.u = vec3_scale(u, viewport_width);
    camera->viewport.v = vec3_scale(v, -viewport_height);

    camera->viewport.pos_at00 =
        vec3_sub(vec3_sub(vec3_sub(camera->origin, vec3_scale(w, focus_dist)),
                          vec3_scale(camera->viewport.u, 0.5)),
                 vec3_scale(camera->viewport.v, 0.5));
    // camera->viewport.pos_at00 = vec3_add(
    //     viewport_top_left,
    //     vec3_scale(vec3_add(camera->viewport.dx, camera->viewport.dy), 0.5));

    double defocus_radius = focus_dist * tan(camera->defocus_angle * 0.5);
    camera->defocus_disc_u = vec3_scale(u, defocus_radius);
    camera->defocus_disc_v = vec3_scale(v, defocus_radius);

    return true;
}

/// Calculate the offset generated by (px, py) from `get_ray`
static inline Vec3 pixel_sample() {
    return vec3_scale(
        vec3_from(random_double() - 0.5, random_double() - 0.5, 0.0), 5e-3);
}

/// Offset the rays origin by a random value generated using this function
static inline Vec3 defocus_disk_sample(const Camera *camera) {
    Vec3 p = vec3_random_in_unit_disk();
    return vec3_add(vec3_add(vec3_scale(camera->defocus_disc_u, p.x),
                             vec3_scale(camera->defocus_disc_v, p.y)),
                    camera->origin);
}

/// Get ray from camera origin to the (x, y) position in its viewport.
/// This value is offset by the (px, py) for better anti aliasing.
Ray get_ray(const Camera *camera, const double x, const double y) {
    Vec3 sample = pixel_sample();
    Vec3 vp_pixel =
        vec3_add(camera->viewport.pos_at00,
                 vec3_add(vec3_scale(camera->viewport.u, x + sample.x),
                          vec3_scale(camera->viewport.v, y + sample.y)));
    // vp_pixel = vec3_add(vp_pixel, pixel_sample());

    Vec3 ray_origin = camera->defocus_angle <= 0.0
                          ? camera->origin
                          : defocus_disk_sample(camera);

    Vec3 ray_direction = vec3_sub(vp_pixel, ray_origin);
    double ray_time = random_double();

    return timed_ray_from(ray_origin, ray_direction, ray_time);
}

/// Recursively calculate to color of a ray when cast into the world.
/// The ray can only hit an object `depth` times before ending.
Vec3 ray_color(const Ray *ray, const int depth, const Hittables *world) {
    if (depth <= 0) {
        return vec3_zero();
    }
    HitRecord hr;
    Material *material;
    if (hit_any(world, ray, &(Interval){1e-3, INFINITY}, &hr, &material)) {
        Ray scattered;
        Vec3 attenuation;
        if (material->scatter(material, ray, &hr, &scattered, &attenuation)) {
            return vec3_scale_from_vec3(ray_color(&scattered, depth - 1, world),
                                        attenuation);
        }
        return vec3_zero();
    }
    // Create a linear gradient background where ray hits nothing
    Vec3 unit = vec3_normal(ray->direction);
    double s = 0.5 * (unit.y + 1.0);
    return vec3_add(vec3_scale(vec3_from(1.0, 1.0, 1.0), 1.0 - s),
                    vec3_scale(vec3_from(0.5, 0.7, 1.0), s));
}

Vec3 get_pixel(const Camera *camera, const Hittables *world, const double x,
               const double y) {
    Vec3 rgb = vec3_zero();
    for (int i = 0; i < camera->samples_per_pixel; i++) {
        Ray ray = get_ray(camera, x, y);
        rgb = vec3_add(rgb, ray_color(&ray, camera->max_depth, world));
    }
    rgb = vec3_scale(rgb, 1.0 / camera->samples_per_pixel);
    return rgb;
}
